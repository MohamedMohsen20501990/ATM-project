from abc import ABC,abstractmethod
import datetime
import os
from enum import Enum
import uuid


#enums enumerations 
class TransactionType(Enum):
    WITHDRAW = "Withdraw"
    DEPOSIT = "Deposit"
    BALANCE_INAUIRY = "Balance Inquiery"
    TRANSFER = "Transfer"

class Bank:
    def __init__(self, name, bank_swift_code):
        self.name = name
        self.bank_swift_code = bank_swift_code
        self.accounts = {}
        
    def add_customer(self, customer):
        for account in customer.accounts.values():
            self.accounts[account.account_number] = account  
                              
class Customer:
    def __init__(self, name, address, phone_number, email):
        self.name = name
        self.address = address
        self.phone_number = phone_number
        self.email = email
        self.accounts = {}
    
    def add_account(self, account):
        self.accounts[account.account_number] = account   

class Account:
    def __init__(self, account_number):
        self.account_number = account_number
        self.balance = 0
        self.linked_card = None
        self.transaction_history = []
    
    def link_card(self,card):
        self.linked_card= card    
    
    def add_transaction(self, transaction):
        self.transaction_history.append(transaction)   
    
    def display_transaction_history(self):
        if not self.transaction_history:
            print("No transactions available")
            return
        print("Printing transaction history: \n")
        for transaction in self.transaction_history:
            print(f"Transaction ID: {transaction.transaction_id}\nTransaction Type: {transaction.transaction_type.value}\nTransaction Amount {transaction.amount}\nTime: {transaction.timestamp}\n")     

class Card:
    def __init__(self, number, pin):
        self.number = number
        self.__pin = pin
        
    # getter for the pin
    def get_pin(self):
        return self.__pin  
    # pin setter
    def set_pin(self, old_pin, new_pin):
        if self.__pin == old_pin:
            self.__pin == new_pin
            return True
        else:
            return False
                    
        
class Keypad:
    def get_input(self, message):
        return input(message)        
        
class Screen:
    def show_message(self, message):
        print(message)
    
    def clear_screen(slef):
        os.system('cls' if os.name == "nt" else 'clear')    

# single responsibility principle        
class CardReader:
    def __init__(self,atm, bank):
        self.authenticator = Authenticator(bank)
        self.atm = atm
        
    def insert_card(self, card):
        pin = self.atm.keypad.get_input("Please enter yout PIN code: ")
        account = self.authenticator.authenticate(card.number, pin)
        if account:
            self.atm.display_main_menu(account)
        else:
            self.atm.screen.show_message("Invalid card or PIN")
            return None     
        
# single responsibility principle    
class Authenticator:
    def __init__(self, bank):
        self.bank = bank
    def authenticate(self, card_number, pin):
        for account in self.bank.accounts.values():
            if account.linked_card and account.linked_card.number == card_number and account.linked_card.get_pin() == pin:
                return account
        return None
                                
class ATM:
    def __init__(self, bank, atm_location):
        self.bank = bank
        self.atm_location = atm_location
        self.keypad = Keypad()
        self.screen = Screen()
        
    
        
    def display_main_menu(self, account):
        message = """
        1. Withdraw
        2. Deposit
        3. Balance Inquiry
        4. View Transactions
        5. Exit
        Choose an option: """
        while True:
            choice = self.keypad.get_input(message)
            if choice == "5":
                self.screen.show_message("Card Ejecting .... ")
                self.screen.show_message("GOODBYE")
                break 
            self.handle_transaction(choice, account)
                    
    def handle_transaction(self, choice, account):
        transaction = None
        try:
            match choice:
                case "1":
                    amount = int(self.keypad.get_input("Enter amount to withdraw: "))
                    transaction  = WithdrawTransaction(amount)
                case "2":
                    amount = int(self.keypad.get_input("Enter amount to Deposit: "))
                    transaction  = DepositTransaction(amount)
                case "3":
                    transaction = BalanceInquiry()
                case "4":
                    account.display_transaction_history()
                case _:
                    self.screen.show_message("Invalid Choice")  
            if transaction:         
                transaction.execute(account)  # perfect exapmle of the polymorphism principle  
            self.keypad.get_input("\n press enter to continue ...")
            self.screen.clear_screen()            
        except ValueError:
            self.screen.show_message("Invalid amount enteredn Please try again. ")
                           
class Transaction(ABC):
    
    
    def __init__(self, transaction_type, amount=None):
        self.transaction_id = uuid.uuid4()
        self.timestamp = datetime.datetime.now()
        self.transaction_type = transaction_type
        self.amount = amount
        
    @abstractmethod
    def execute(self):
        pass     
    
class WithdrawTransaction(Transaction):
    def __init__(self, amount):
        super().__init__(TransactionType.WITHDRAW, amount)
        self.amount = amount
    # polymorphism
    def execute(self, account):
        if account.balance >= self.amount:
            account.balance -= self.amount
            print(f"withdrawl successful, you new balance {account.balance}")
            account.add_transaction(self)
        else:
            print("Insufficent funds")

class DepositTransaction(Transaction):
    def __init__(self, amount):
        super().__init__(TransactionType.DEPOSIT, amount)
        self.amount = amount
        
    def execute(self, account):
        account.balance += self.amount
        print(f"Deposit successful, you new balance {account.balance}")
        account.add_transaction(self)
        
class BalanceInquiry(Transaction):
    def __init__(self):
        super().__init__(TransactionType.BALANCE_INAUIRY, amount=0)
        
    def execute(self,account):
        self.amount=account.balance 
        print(f"your balance is {account.balance}")
        account.add_transaction(self)
        
        
my_bank = Bank("HSBC", "HSBCEGYPTXXX")
customer_1 =Customer("omar", "42 boulak eldakror", "0121436242", "omar_gmail.com")
account_1 = Account("12345")

customer_1.add_account(account_1)      
my_bank.add_customer(customer_1)


print(customer_1.accounts)  
        
card_1 = Card("1255544665888", "1111") 
account_1.link_card(card_1)
print(account_1.linked_card.number)       


atm = ATM(my_bank, "Elgiza")
card_reader = CardReader(atm, my_bank)
card_reader.insert_card(card_1)

    
            
        
        
                             
        
                
        
